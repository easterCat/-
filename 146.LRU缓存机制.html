<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>Document</title>
  </head>
  <body></body>
  <script>
    // LRU（Least recently used，最近最少使用）算法。该算法的观点是，最近被访问的数据那么它将来访问的概率就大，缓存满的时候，优先淘汰最无人问津者。
    function LRUCache(capacity) {
      this.cache = [];
      this.capacity = capacity;
    }

    LRUCache.prototype.put = function(key, value) {
      let index = this.cache.findIndex(item => item.key === key);
      if (this.cache[index]) {
        let remove = this.cache.splice(index, 1)[0];
        remove.value = value;
        this.cache.push(remove);
      } else {
        if (this.cache.length >= this.capacity) {
          this.cache.shift();
        }

        this.cache.push({
          key,
          value
        });
      }
    };

    LRUCache.prototype.get = function(key) {
      let index = this.cache.findIndex(item => item.key === key);
      if (this.cache[index]) {
        let remove = this.cache.splice(index, 1)[0];
        this.cache.push(remove);
        return remove.value;
      } else {
        return -1;
      }
    };

    let lru = new LRUCache(2);
    lru.put(2, 1);
    lru.put(2, 2);
    console.log("lru.get(2) :", lru.get(2)); // need 2
    lru.put(1, 1);
    lru.put(4, 1);
    console.log("lru.get(2) :", lru.get(2)); // need -1
  </script>

  <!-- <script>
        // 执行用时 :368 ms   内存消耗:59.4m
        // LRU（Least recently used，最近最少使用）算法。该算法的观点是，最近被访问的数据那么它将来访问的概率就大，缓存满的时候，优先淘汰最无人问津者。
         function LRUCache(capacity) {
      this.cache = [];
      this.capacity = capacity;
    }

    LRUCache.prototype.put = function(key, value) {
      let index = this.cache.findIndex(item => item.key === key);
      if (this.cache[index]) {
        let remove = this.cache.splice(index, 1)[0];
        remove.value = value;
        this.cache.push(remove);
      } else {
        if (this.cache.length >= this.capacity) {
          this.cache.shift();
        }

        this.cache.push({
          key,
          value
        });
      }
    };

    LRUCache.prototype.get = function(key) {
      let index = this.cache.findIndex(item => item.key === key);
      if (this.cache[index]) {
        let remove = this.cache.splice(index, 1)[0];
        this.cache.push(remove);
        return remove.value;
      } else {
        return -1;
      }
    };
    
        let lru = new LRUCache(2);
        lru.put(2, 1);
        lru.put(2, 2);
        console.log("lru.get(2) :", lru.get(2)); // need 2
        lru.put(1, 1);
        lru.put(4, 1);
        console.log("lru.get(2) :", lru.get(2)); // need -1
      </script> -->
</html>
